# HG changeset patch
# User jkantor@localhost.localdomain
# Date 1172272607 28800
# Node ID a7ec047172ff1c85c1c9c36ba7b505557aa60c35
# Parent  c62f949939469b39d39f16d0e62d611d9ce6140a
# Parent  4ded176aecef768db80a010ea685c6fb94c53fba
merged Williams support for fast matrix vector multiplication

diff -r c62f94993946 -r a7ec047172ff sage/combinat/sloane_functions.py
--- a/sage/combinat/sloane_functions.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/combinat/sloane_functions.py	Fri Feb 23 15:16:47 2007 -0800
@@ -87,7 +87,9 @@ AUTHORS:
 # I. Define the generic Sloane sequence class.
 ########################################################################
 
-# just used for handy .load, .save, etc. 
+# just used for handy .load, .save, etc.
+
+import inspect
 from sage.structure.sage_object import SageObject  
 from sage.misc.misc import srange
 from sage.rings.integer_ring import ZZ
@@ -6886,136 +6888,62 @@ class A000100(SloaneSequence):
 #############################################################
 
 class Sloane(SageObject):
-    pass
+    r"""
+    A collection of Sloane generating functions.
+
+    This class inspects sage.combinat.sloane_functions, accumulating all the SloaneSequence classes starting with 'A'.  These are listed for tab completion, but not instantiated until requested.
+
+    EXAMPLES:
+        Ensure we have lots of entries:
+        sage: len(sloane.trait_names()) > 100
+        True
+
+        And ensure none are being incorrectly returned:
+        sage: [ None for n in sloane.trait_names() if not n.startswith('A') ]
+        []
+
+        Ensure we can access dynamic constructions and cache correctly:
+        sage: s = sloane.A000587
+        sage: s is sloane.A000587
+        True
+
+        And that we can access other functions in parent classes:
+        sage: sloane.__class__
+        <class 'sage.combinat.sloane_functions.Sloane'>
+
+    AUTHOR: Nick Alexander
+    """
+
+    def trait_names(self):
+        r"""List Sloane generating functions for tab-completion.
+
+        The member classes are inspected from module sage.combinat.sloane_functions.
+
+        They must be sub classes of SloaneSequence and must start with 'A'.  These
+        restrictions are only to prevent typos, incorrect inspecting, etc.
+        """
+        try:
+            return self.__trait_names
+        except AttributeError:
+            import sage.combinat.sloane_functions
+            xs = inspect.getmembers(sage.combinat.sloane_functions, inspect.isclass)
+            self.__trait_names = [ n for (n, c) in xs if n.startswith('A') and issubclass(c, SloaneSequence) ]
+            return self.__trait_names
+
+    def __getattribute__(self, name):
+        r"""Construct and cache unique instances of Sloane generating function objects
+        .
+        """
+        try:
+            return SageObject.__getattribute__(self, name)
+        except AttributeError:
+            try:
+                import sage.combinat.sloane_functions
+                f = getattr(sage.combinat.sloane_functions, name)
+                seq = f()
+                setattr(self, name, seq)
+                return seq
+            except AttributeError:
+                raise AttributeError, name
+
 sloane = Sloane()
-
-sloane.A000001 = A000001()
-sloane.A000004 = A000004()
-sloane.A000005 = A000005()
-sloane.A000007 = A000007()
-sloane.A000009 = A000009()
-sloane.A000010 = A000010()
-sloane.A000012 = A000012()
-sloane.A000015 = A000015()
-sloane.A000016 = A000016()
-sloane.A000027 = A000027()
-sloane.A000030 = A000030()
-sloane.A000032 = A000032()
-sloane.A000035 = A000035()
-sloane.A000040 = A000040()
-sloane.A000043 = A000043()
-sloane.A000041 = A000041()
-sloane.A000045 = A000045()
-sloane.A000069 = A000069()
-sloane.A000073 = A000073()
-sloane.A000079 = A000079()
-sloane.A000085 = A000085()
-sloane.A000100 = A000100()
-sloane.A000108 = A000108()
-sloane.A000110 = A000110()
-sloane.A000120 = A000120()
-sloane.A000124 = A000124()
-sloane.A000129 = A000129()
-sloane.A000142 = A000142()
-sloane.A000153 = A000153()
-sloane.A000165 = A000165()
-sloane.A000166 = A000166()
-sloane.A000169 = A000169()
-sloane.A000203 = A000203()
-sloane.A000204 = A000204()
-sloane.A000213 = A000213()
-sloane.A000217 = A000217()
-sloane.A000225 = A000225()
-sloane.A000244 = A000244()
-sloane.A000255 = A000255()
-sloane.A000261 = A000261()
-sloane.A000272 = A000272()
-sloane.A000290 = A000290()
-sloane.A000292 = A000292()
-sloane.A000302 = A000302()
-sloane.A000312 = A000312()
-sloane.A000326 = A000326()
-sloane.A000330 = A000330()
-sloane.A000396 = A000396()
-sloane.A000578 = A000578()
-sloane.A000583 = A000583()
-sloane.A000587 = A000587()
-sloane.A000668 = A000668()
-sloane.A000670 = A000670()
-sloane.A000720 = A000720()
-sloane.A000796 = A000796()
-sloane.A000961 = A000961()
-sloane.A000984 = A000984()
-sloane.A001006 = A001006()
-sloane.A001055 = A001055()
-sloane.A001045 = A001045()
-sloane.A001109 = A001109()
-sloane.A001110 = A001110()
-sloane.A001147 = A001147()
-sloane.A001157 = A001157()
-sloane.A001189 = A001189()
-sloane.A001221 = A001221()
-sloane.A001222 = A001222()
-sloane.A001227 = A001227()
-sloane.A001333 = A001333()
-sloane.A001358 = A001358()
-sloane.A001405 = A001405()
-sloane.A001477 = A001477()
-sloane.A001694 = A001694()
-sloane.A001836 = A001836()
-sloane.A001906 = A001906()
-sloane.A001909 = A001909()
-sloane.A001910 = A001910()
-sloane.A001969 = A001969()
-sloane.A002110 = A002110()
-sloane.A002113 = A002113()
-sloane.A002378 = A002378()
-sloane.A002275 = A002275()
-sloane.A002620 = A002620()
-sloane.A002808 = A002808()
-sloane.A003418 = A003418()
-sloane.A004086 = A004086()
-sloane.A004526 = A004526()
-sloane.A005100 = A005100()
-sloane.A005101 = A005101()
-sloane.A005117 = A005117()
-sloane.A005408 = A005408()
-sloane.A005843 = A005843()
-sloane.A006318 = A006318()
-sloane.A006882 = A006882()
-sloane.A006530 = A006530()
-sloane.A007318 = A007318()
-sloane.A008275 = A008275()
-sloane.A008277 = A008277()
-sloane.A008683 = A008683()
-sloane.A010060 = A010060()
-sloane.A015521 = A015521()
-sloane.A015523 = A015523()
-sloane.A015530 = A015530()
-sloane.A015531 = A015531()
-sloane.A018252 = A018252()
-sloane.A020639 = A020639()
-sloane.A046660 = A046660()
-sloane.A049310 = A049310()
-sloane.A051959 = A051959()
-sloane.A055790 = A055790()
-sloane.A061084 = A061084()
-sloane.A064553 = A064553()
-sloane.A079922 = A079922()
-sloane.A079923 = A079923()
-sloane.A082411 = A082411()
-sloane.A083103 = A083103()
-sloane.A083104 = A083104()
-sloane.A083105 = A083105()
-sloane.A083216 = A083216()
-sloane.A083216 = A083216()
-sloane.A090010 = A090010()
-sloane.A090012 = A090012()
-sloane.A090013 = A090013()
-sloane.A090014 = A090014()
-sloane.A090015 = A090015()
-sloane.A090016 = A090016()
-sloane.A111774 = A111774()
-sloane.A111775 = A111775()
-sloane.A111776 = A111776()
-sloane.A111787 = A111787()
diff -r c62f94993946 -r a7ec047172ff sage/databases/all.py
--- a/sage/databases/all.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/databases/all.py	Fri Feb 23 15:16:47 2007 -0800
@@ -16,6 +16,8 @@ This file gathers together all the table
 
     * Sloane's tables -- sloane_sequence, sloane_find
 
+    * SymbolicData() -- many benchmark and testing ideals
+
     * Linear codes -- linear_code_bound
 
 EXAMPLES:
@@ -33,6 +35,9 @@ EXAMPLES:
 
     sage: SteinWatkinsDatabase()
     The Stein-Watkins database of elliptic curves
+
+    sage: SymbolicData()
+    SymbolicData with 372 ideals
 
 """
 
@@ -71,6 +76,8 @@ from install import database_install
 
 from sloane import sloane_sequence, sloane_find, SloaneEncyclopedia
 
+from symbolic_data import SymbolicData
+
 from lincodes import linear_code_bound
 
 from odlyzko import zeta_zeros
diff -r c62f94993946 -r a7ec047172ff sage/databases/symbolic_data.py
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/databases/symbolic_data.py	Fri Feb 23 15:16:47 2007 -0800
@@ -0,0 +1,145 @@
+"""nodoctest
+Very thin wrapper for the SymbolicData benchmark and test ideals as
+published on http://www.symbolicdata.org . From that website:
+
+    For different purposes algorithms and implementations are tested on
+    certified and reliable data. The development of tools and data for
+    such tests is usually 'orthogonal' to the main implementational
+    efforts, it requires different skills and technologies and is not
+    loved by programmers. On the other hand, in many cases tools and data
+    could easily be reused - with slight modifications - across similar
+    projects. The SymbolicData Project is set out to coordinate such
+    efforts within the Computer Algebra Community.  Commonly collected
+    certified and reliable data can also be used to compare otherwise
+    incomparable approaches, algorithms, and implementations. Benchmark
+    suites and Challenges for symbolic computations are not as well
+    established as in other areas of computer science. This is probably
+    due to the fact that there are not yet well agreed aims of such a
+    benchmarking. Nevertheless various (often high quality) special
+    benchmarks are scattered through the literature.  During the last
+    years efforts toward collection of test data for symbolic
+    computations were intensified. They focused mainly on the creation of
+    general benchmarks for different areas of symbolic computation and
+    the collection of such activities on different Web site.  For further
+    qualification of these efforts it would be of great benefit to create
+    a commonly available digital archive of these special benchmark data
+    scattered through the literature. This would provide the community
+    with an electronic repository of certified data that could be
+    addressed and extended during further development.
+
+EXAMPLE:
+    sage: sd = SymbolicData(); sd
+    SymbolicData with 372 ideals
+
+    sage: sd.ZeroDim__example_1
+    Ideal (-10 + x2^2 + x1^2, -16 + 2*x2^2 + x1*x2 + x1^2) of Polynomial Ring in x1, x2 over Rational Field
+
+    sage: sd.Katsura_3
+    Ideal (-1 + 2*u3 + 2*u2 + 2*u1 + u0, -1*u2 + 2*u1*u3 + u1^2 + 2*u0*u2, 2*u2*u3 - u1 + 2*u1*u2 + 2*u0*u1, 2*u3^2 + 2*u2^2 + 2*u1^2 - u0 + u0^2) of Polynomial Ring in u0, u1, u2, u3 over Rational Field
+
+
+    sage: sd.get_ideal('Katsura_3',GF(127),'degrevlex')
+    Ideal (126 + 2*u3 + 2*u2 + 2*u1 + u0, 126*u2 + 2*u1*u3 + u1^2 + 2*u0*u2, 2*u2*u3 + 126*u1 + 2*u1*u2 + 2*u0*u1, 2*u3^2 + 2*u2^2 + 2*u1^2 + 126*u0 + u0^2) of Polynomial Ring in u0, u1, u2, u3 over Finite Field of size 127
+
+AUTHOR: Martin Albrecht <malb@informatik.uni-bremen.de>    
+
+"""
+import os
+from xml.dom.minidom import parse
+from sage.rings.rational_field import QQ
+from sage.rings.ideal import Ideal
+from sage.rings.polynomial_ring import PolynomialRing
+
+
+class SymbolicData:
+    """
+    Access to the benchmark and test ideals of the SymbolicData
+    suite. This class needs the optional database-symbolicdata package
+    to be installed.
+    """
+    def __init__(self):
+
+        path=os.environ["SAGE_ROOT"]+"/data/symbolic_data"
+        self.__intpath = path + "/Data/XMLResources/INTPS/"
+        self.__genpath = path + "/Data/XMLResources/GenPS/"
+
+        
+    def get_ideal(self, name, base_ring=QQ, term_order="degrevlex"):
+        """
+        Returns the ideal given by 'name' over the base ring given by
+        'base_ring' in a polynomial ring with the term order given by
+        'term_order'.
+
+        INPUT:
+            name -- name as in the SymbolicData package
+            base_ring -- base ring for the polynomial ring (default: QQ)
+            term_order -- term order for the polynomial ring (default: degrevlex)
+
+        OUTPUT:
+            ideal as given by name in MPolynomialRing(base_ring,vars,term_order)
+        
+        """
+
+        def _getTextFromNode(node):
+            t = ""
+            for n in node.childNodes:
+                if n.nodeType == n.TEXT_NODE:
+                    t += str(n.nodeValue)
+                else:
+                    raise NotTextNodeError
+            return t
+
+        def _dom2ideal(node):
+            """
+            """
+            l = []
+
+            if str(node.nodeName) in ['vars','poly']:
+                l.append(_getTextFromNode(node))
+
+            for c in node.childNodes:
+                l += _dom2ideal(c)
+
+            return l
+
+        name = name.replace('__','.')
+
+        try:
+            name = self.__intpath + name + ".xml"
+            open(name)
+        except IOError:
+            try:
+                name = self.__genpath + name + ".xml"
+                open(name)
+            except IOError:
+                raise AttributeError, "Ideal not found on disk"
+        
+
+        dom = parse(name)
+        res = _dom2ideal(dom)
+        vars,polys = res[0].replace("_",""),[p.replace("_","") for p in res[1:]]
+
+        return Ideal(PolynomialRing(base_ring, len(vars.split(",")), vars), polys)
+    
+
+    def __repr__(self):
+        try:
+            l = len(self.trait_names())
+        except AttributeError:
+            l = 0
+        return "SymbolicData with %d ideals"%l
+
+    def __getattr__(self, name):
+        return self.get_ideal(name)
+
+    def trait_names(self):
+        """
+        """
+        if hasattr(self,"__ideals"): return self.__ideals
+        try:
+            __ideals = [s.replace('.xml','') for s in  os.listdir(self.__intpath)]
+            __ideals += [s.replace('.xml','') for s in  os.listdir(self.__genpath)]
+            self.__ideals = [s.replace('.', '__') for s in __ideals]
+            return self.__ideals
+        except OSError:
+            raise AttributeError, "Could not find symbolic data, you should perhaps install the optional package"
diff -r c62f94993946 -r a7ec047172ff sage/ext/cdefs.pxi
--- a/sage/ext/cdefs.pxi	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/ext/cdefs.pxi	Fri Feb 23 15:16:47 2007 -0800
@@ -42,6 +42,7 @@ cdef extern from "gmp.h":
     # The mpz type
     void mpz_abs (mpz_t rop, mpz_t op)
     void mpz_add (mpz_t rop, mpz_t op1, mpz_t op2)
+    void mpz_addmul (mpz_t rop, mpz_t op1, mpz_t op2)
     void mpz_and (mpz_t rop, mpz_t op1, mpz_t op2)
     void mpz_ior (mpz_t rop, mpz_t op1, mpz_t op2)
     void mpz_clear(mpz_t integer)
diff -r c62f94993946 -r a7ec047172ff sage/ext/multi_modular.h
--- a/sage/ext/multi_modular.h	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/ext/multi_modular.h	Fri Feb 23 15:16:47 2007 -0800
@@ -1,14 +1,4 @@
 #define mod_int size_t
 
-
-/* This is the largest value we can do arithmatic on without risking overflowing. 
- * It will be optimized to a constant if any optimization is turned on. 
- * The expression below assumes unsigned. 
- */
-#define MOD_INT_MAX ((1 << (sizeof(mod_int)*4)) - 1)
-#define MOD_INT_OVERFLOW ((1 << (sizeof(mod_int)*8)) - 1)
-
-/* Don't want to be up against the limit so 
- * we have room to gather. 
- */
-#define START_PRIME_MAX (MOD_INT_MAX/7)
\ No newline at end of file
+#define SIZE_MAX (size_t)-1
+#define MOD_INT_OVERFLOW SIZE_MAX
diff -r c62f94993946 -r a7ec047172ff sage/ext/multi_modular.pxd
--- a/sage/ext/multi_modular.pxd	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/ext/multi_modular.pxd	Fri Feb 23 15:16:47 2007 -0800
@@ -6,8 +6,7 @@ from sage.rings.integer cimport Integer
 
 cdef extern from "multi_modular.h":
     ctypedef unsigned long mod_int
-    mod_int MOD_INT_MAX
-    mod_int START_PRIME_MAX
+    mod_int MOD_INT_OVERFLOW
     
 cdef class MultiModularBasis_base:
     cdef int      n
diff -r c62f94993946 -r a7ec047172ff sage/ext/multi_modular.pyx
--- a/sage/ext/multi_modular.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/ext/multi_modular.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -26,8 +26,11 @@ cdef arith_llong ai
 cdef arith_llong ai
 ai = arith_llong()
 
+# We use both integer and double operations, hence the min. 
+MAX_MODULUS = min(int(sqrt(MOD_INT_OVERFLOW)-1), int(2**20))
+
+
 # TODO: have one global instance for sharing, copy for MutableMultiModularBasis
-
 cdef class MultiModularBasis_base:
     r"""
     This class stores a list of machine-sized prime numbers, 
@@ -46,7 +49,7 @@ cdef class MultiModularBasis_base:
         and initalize the first element of that list. 
         """
         cdef mod_int p
-        p = next_prime(START_PRIME_MAX-1)
+        p = next_prime(MAX_MODULUS/7)
 
         self.n = 1
 
@@ -76,7 +79,7 @@ cdef class MultiModularBasis_base:
         INPUT:
             height -- as integer 
                           determines how many primes are computed
-                          (their product must be at least height)
+                          (their product will be at least 2*height)
                       as list
                           a list of prime moduli to start with
         """
@@ -90,7 +93,7 @@ cdef class MultiModularBasis_base:
             if self.moduli == NULL or self.partial_products == NULL or self.C == NULL:
                 raise MemoryError, "out of memory allocating multi-modular prime list"
             for i from 0 <= i < len(m):
-                if m[i] > MOD_INT_MAX:
+                if m[i] > MAX_MODULUS:
                     raise ValueError, "given modulus cannot be manipulated in a single machine word"
                 self.moduli[i] = m[i]
             for i from 1 <= i < len(m):
@@ -108,7 +111,7 @@ cdef class MultiModularBasis_base:
         h = ZZ(height)
         self._extend_moduli_to_height_c(h.value)
     
-    cdef int _extend_moduli_to_height_c(self, mpz_t height) except -1:
+    cdef int _extend_moduli_to_height_c(self, mpz_t height0) except -1:
         r"""
         Expand the list of primes and perform precomputations. 
         
@@ -116,6 +119,9 @@ cdef class MultiModularBasis_base:
             height -- determines how many primes are computed
                       (their product must be at least height)
         """
+        cdef mpz_t height
+        mpz_init(height)
+        mpz_mul_2exp(height, height0, 1)
         if mpz_cmp(height, self.partial_products[self.n-1]) <= 0:
             return self.n
         cdef int i
@@ -130,6 +136,7 @@ cdef class MultiModularBasis_base:
             new_moduli.append(p)
             M *= p
             new_partial_products.append(M)
+        mpz_clear(height)
             
         cdef int new_count, old_count
         old_count = self.n
diff -r c62f94993946 -r a7ec047172ff sage/interfaces/expect.py
--- a/sage/interfaces/expect.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/interfaces/expect.py	Fri Feb 23 15:16:47 2007 -0800
@@ -81,7 +81,7 @@ class Expect(ParentWithBase):
                  script_subdirectory="", restart_on_ctrlc=False,
                  verbose_start=False, init_code=[], max_startup_time=30,
                  logfile = None, eval_using_file_cutoff=0,
-                 do_cleaner = True):
+                 do_cleaner = True, path=None):
 
         self.__is_remote = False
         if command == None:
@@ -102,10 +102,13 @@ class Expect(ParentWithBase):
         self._prompt = prompt
         self._restart_on_ctrlc = restart_on_ctrlc
         self.__verbose_start = verbose_start
-        if script_subdirectory == None:
+        if not path is None:
+            self.__path = path
+        elif script_subdirectory is None:
             self.__path = '.'
         else:
-            self.__path = '%s/data/extcode/%s/%s'%(SAGE_ROOT,self.__name, self.__script_subdirectory)
+            self.__path = '%s/data/extcode/%s/%s'%(SAGE_ROOT,self.__name,
+                                                   self.__script_subdirectory)
         self.__initialized = False
         self.__seq = -1
         self._expect = None
diff -r c62f94993946 -r a7ec047172ff sage/interfaces/sage0.py
--- a/sage/interfaces/sage0.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/interfaces/sage0.py	Fri Feb 23 15:16:47 2007 -0800
@@ -102,7 +102,7 @@ class Sage(Expect):
     """
     def __init__(self, maxread=10000, script_subdirectory=None,
                        logfile=None,  preparse=True, server=None,
-                       do_cleaner=True, python=True):
+                       do_cleaner=True, python=True, path=None):
         if python:
             command = "sage -python -u"
             prompt = ">>>"
@@ -123,6 +123,7 @@ class Sage(Expect):
                         logfile = logfile,
                         init_code = init_code,
                         do_cleaner = do_cleaner,
+                        path = path
                         )
         self._preparse = preparse
         self._is_local = (server is None)
diff -r c62f94993946 -r a7ec047172ff sage/libs/linbox/linbox_wrap.cpp
--- a/sage/libs/linbox/linbox_wrap.cpp	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/libs/linbox/linbox_wrap.cpp	Fri Feb 23 15:16:47 2007 -0800
@@ -1,10 +1,14 @@
+#include <iostream>
+#include <gmp.h>
+#include "linbox_wrap.h"
+
+
+
 
 /*************************************************************************
    dense modulo Z/nZ
 *************************************************************************/
 
-#include <iostream>
-#include <gmp.h>
 #include <linbox/integer.h>
 #include <linbox/matrix/blas-matrix.h>
 #include <linbox/matrix/matrix-domain.h>
@@ -15,8 +19,6 @@
 #include <linbox/solutions/charpoly.h>
 #include <linbox/ring/givaro-polynomial.h>
 #include <linbox/field/modular.h>
-
-#include "linbox_wrap.h"
 
 using namespace LinBox;
 using namespace std;
@@ -225,6 +227,31 @@ int linbox_modn_dense_matrix_matrix_mult
 
 
 
+/*************************************************************************
+   sparse modulo Z/nZ
+*************************************************************************/
+
+
+int linbox_modn_sparse_rank(mod_int modulus,  
+			   mod_int** matrix, size_t nrows, size_t ncols) {
+
+  /*    typedef Modular<double> Field;
+    Field F(modulus);
+    SparseMatrix<Field, Vector<Field>::SparseSeq > B (ms);
+
+    mod_int* row;
+    for (size_t i=0; i < nrows; i++) {
+	row = matrix[i];
+	for (size_t j=0; j < ncols; j++)
+	    A.setEntry(i, j, (double)row[j]);
+	}
+
+    unsigned long r;
+    rank(r, A);
+    return r;
+  */
+}
+
 
 
 /*************************************************************************
diff -r c62f94993946 -r a7ec047172ff sage/libs/linbox/linbox_wrap.h
--- a/sage/libs/linbox/linbox_wrap.h	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/libs/linbox/linbox_wrap.h	Fri Feb 23 15:16:47 2007 -0800
@@ -5,6 +5,9 @@
 #else 
 #define EXTERN
 #endif
+
+/* Turn off lots of verbosity in the output of linbox functions */
+#define DISABLE_COMMENTATOR
 
 #include<stddef.h>
 typedef size_t mod_int; 
diff -r c62f94993946 -r a7ec047172ff sage/libs/ntl/decl.pxi
--- a/sage/libs/ntl/decl.pxi	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/libs/ntl/decl.pxi	Fri Feb 23 15:16:47 2007 -0800
@@ -89,6 +89,7 @@ cdef extern from "ntl_wrap.h":
     ZZ* ZZX_resultant(ZZX* x, ZZX* y, int proof)
     ZZ* ZZX_norm_mod(ZZX* x, ZZX* y, int proof)
     ZZ* ZZX_discriminant(ZZX* x, int proof)
+    ZZ* ZZX_polyeval(ZZX* x, ZZ* a)
     ZZX* ZZX_charpoly_mod(ZZX* x, ZZX* y, int proof)
     ZZX* ZZX_minpoly_mod(ZZX* x, ZZX* y)
     void ZZX_clear(ZZX* x)
diff -r c62f94993946 -r a7ec047172ff sage/libs/ntl/ntl.pyx
--- a/sage/libs/ntl/ntl.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/libs/ntl/ntl.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -1019,6 +1019,10 @@ cdef class ntl_ZZX:
         _sig_on
         return make_ZZ(ZZX_discriminant(self.x, proof))
 
+    #def __call__(self, ntl_ZZ a):
+    #    _sig_on
+    #    return make_ZZ(ZZX_polyeval(self.x, a.x))
+
     def charpoly_mod(self, ntl_ZZX modulus, proof=True):
         """
         Return the characteristic polynomial of this polynomial modulo
diff -r c62f94993946 -r a7ec047172ff sage/libs/ntl/ntl_wrap.cc
--- a/sage/libs/ntl/ntl_wrap.cc	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/libs/ntl/ntl_wrap.cc	Fri Feb 23 15:16:47 2007 -0800
@@ -650,6 +650,14 @@ void ZZX_preallocate_space(struct ZZX* x
   x->SetMaxLength(n);
 }
 
+/*
+EXTERN struct ZZ* ZZX_polyeval(struct ZZX* f, struct ZZ* a)
+{
+  ZZ* b = new ZZ();
+  *b = PolyEval(*f, *a);
+  return b;
+}
+*/
 
 ///////////////////////////////////////////////
 //////// ZZ_pX //////////
diff -r c62f94993946 -r a7ec047172ff sage/libs/ntl/ntl_wrap.h
--- a/sage/libs/ntl/ntl_wrap.h	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/libs/ntl/ntl_wrap.h	Fri Feb 23 15:16:47 2007 -0800
@@ -2,6 +2,7 @@
 #include <NTL/ZZ.h>
 #include <NTL/ZZX.h>
 #include <NTL/ZZ_pXFactoring.h>
+/* #include <NTL/ZZXFactoring.h> */
 #include <NTL/mat_ZZ.h>
 #include <NTL/GF2E.h>
 #include <NTL/GF2X.h>
@@ -120,6 +121,7 @@ EXTERN struct ZZX* ZZX_invert_and_trunca
 EXTERN struct ZZX* ZZX_invert_and_truncate(struct ZZX* x, long m);
 EXTERN struct ZZX* ZZX_multiply_mod(struct ZZX* x, struct ZZX* y,  struct ZZX* modulus);
 EXTERN struct ZZ* ZZX_trace_mod(struct ZZX* x, struct ZZX* y);
+/* EXTERN struct ZZ* ZZX_polyeval(struct ZZX* f, struct ZZ* a); */
 EXTERN char* ZZX_trace_list(struct ZZX* x);
 EXTERN struct ZZ* ZZX_resultant(struct ZZX* x, struct ZZX* y, int proof);
 EXTERN struct ZZ* ZZX_norm_mod(struct ZZX* x, struct ZZX* y, int proof);
diff -r c62f94993946 -r a7ec047172ff sage/matrix/benchmark.py
--- a/sage/matrix/benchmark.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/benchmark.py	Fri Feb 23 15:16:47 2007 -0800
@@ -2,7 +2,7 @@ from sage.all import *
 
 verbose = False
 
-timeout = 5
+timeout = 10
 
 def report(F, title):
     systems = ['sage', 'magma']
@@ -25,7 +25,9 @@ def report(F, title):
                 t = -timeout
             alarm(0)
             w.append(t)
+        w.append(w[0]/w[1])
         w = tuple(w)
+
         print ('%15.3f'*len(w))%w
     
 
@@ -34,8 +36,14 @@ def report(F, title):
 #######################################################################
 
 def report_ZZ():
-    F = [rank_ZZ, rank2_ZZ, nullspace_ZZ, charpoly_ZZ, smithform_ZZ,
-         matrix_multiply_ZZ, det_ZZ, det_QQ]
+    """
+    Reports all the benchmarks for integer matrices and few
+    rational matrices.
+    TODO: Probably I should start report_QQ as well.
+    """
+    F = [vecmat_ZZ, rank_ZZ, rank2_ZZ, charpoly_ZZ, smithform_ZZ,
+         det_ZZ, det_QQ, matrix_multiply_ZZ, nullspace_ZZ]
+
     title = 'Dense benchmarks over ZZ'
     report(F, title)
 
@@ -91,8 +99,6 @@ s := Cputime(t);
         return float(magma.eval('s'))
     else:
         raise ValueError, 'unknown system "%s"'%system
-        
-
 
 
 def rank_ZZ(n=500, min=0, max=9, system='sage'):
@@ -203,6 +209,38 @@ s := Cputime(t);
     else:
         raise ValueError, 'unknown system "%s"'%system
     
+def matrix_add_ZZ(n=200, min=-9, max=9, system='sage', times=10):
+    """
+    Matrix addition over ZZ
+    Given an n x n (with n=200) matrix A and B over ZZ with random entries
+    between min=-9 and max=9, inclusive, compute A + B.
+    """
+    if system == 'sage':
+        A = random_matrix(ZZ, n, n, x=min, y=max+1)
+        B = random_matrix(ZZ, n, n, x=min, y=max+1)
+        t = cputime()
+        for z in range(times):
+            v = A + B
+        return cputime(t)/times
+    elif system == 'magma':
+        code = """
+n := %s;
+min := %s;
+max := %s;
+A := MatrixAlgebra(IntegerRing(), n)![Random(min,max) : i in [1..n^2]];
+B := MatrixAlgebra(IntegerRing(), n)![Random(min,max) : i in [1..n^2]];
+t := Cputime();
+for z in [1..%s] do
+    K := A + B;
+end for;
+s := Cputime(t);
+"""%(n,min,max,times)
+        if verbose: print code
+        magma.eval(code)
+        return float(magma.eval('s'))/times
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+ 
 
 def det_ZZ(n=400, min=1, max=100, system='sage'):
     """
@@ -256,9 +294,58 @@ s := Cputime(t);
     else:
         raise ValueError, 'unknown system "%s"'%system
 
+
+def vecmat_ZZ(n=500, system='sage', min=-9, max=9, times=200):
+    """
+    Vector matrix multiplication over ZZ.
+    
+    Given an n x n (with n=500) matrix A over ZZ with random entries
+    between min=-9 and max=9, inclusive, and v the first row of A,
+    compute the product v * A  200 times. 
+    """
+    if system == 'sage':
+        A = random_matrix(ZZ, n, n, x=min, y=max+1)
+        v = A.row(0)
+        t = cputime()
+        for z in range(times):
+            w = v * A
+        return cputime(t)/times
+    elif system == 'magma':
+        code = """
+n := %s;
+A := MatrixAlgebra(IntegerRing(), n)![Random(%s,%s) : i in [1..n^2]];
+v := A[1];
+t := Cputime();
+for z in [1..%s] do
+    K := v * A;
+end for;
+s := Cputime(t);
+"""%(n,min,max,times)
+        if verbose: print code
+        magma.eval(code)
+        return float(magma.eval('s'))/times
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+    
+    
+    
+
 #######################################################################
 # Dense Benchmarks over GF(p), for small p.
 #######################################################################
+
+def report_GF(p=16411):
+    """
+    Runs all the reports for finite field matrix operations, for
+    prime p=16411. 
+    Note: right now, even though p is an input, it is being ignored!
+    If you need to check the performance for other primes, you can
+    call individual benchmark functions.
+    """
+    F = [rank_GF, rank2_GF, nullspace_GF, charpoly_GF, 
+         matrix_multiply_GF, det_GF]
+    title = 'Dense benchmarks over GF with prime %i' % p
+    report(F, title)
 
 # Nullspace over GF
 
@@ -291,28 +378,58 @@ s := Cputime(t);
 
 def charpoly_GF(n=100, p=16411, system='sage'):
     """
-    Given a n x n (with n=100) matrix over ZZ with random entries,
+    Given a n x n (with n=100) matrix over GF with random entries,
     compute the charpoly.
     """
     if system == 'sage':
-        A = random_matrix(ZZ, n, n, x=min, y=max+1)
+        A = random_matrix(GF(p), n, n)
         t = cputime()
         v = A.charpoly()
         return cputime(t)
     elif system == 'magma':
         code = """
 n := %s;
-A := MatrixAlgebra(IntegerRing(), n)![Random(%s,%s) : i in [1..n^2]];
+A := Random(MatrixAlgebra(GF(%s), n));
 t := Cputime();
 K := CharacteristicPolynomial(A);
 s := Cputime(t);
-"""%(n,min,max)
+"""%(n,p)
         if verbose: print code
         magma.eval(code)
         return magma.eval('s')
     else:
         raise ValueError, 'unknown system "%s"'%system
         
+def matrix_add_GF(n=1000, p=16411, system='sage',times=100):
+    """
+    Given two n x n (with n=1000) matrix over GF with random entries,
+    add them.
+    """
+    if system == 'sage':
+        A = random_matrix(GF(p), n, n)
+        B = random_matrix(GF(p), n, n)
+        t = cputime()
+        for n in range(times):
+            v = A + B
+        return cputime(t)
+    elif system == 'magma':
+        code = """
+n := %s;
+A := Random(MatrixAlgebra(GF(%s), n));
+B := Random(MatrixAlgebra(GF(%s), n));
+t := Cputime();
+for z in [1..%s] do
+    K := A + B;
+end for;
+s := Cputime(t);
+"""%(n,p,p,times)
+        if verbose: print code
+        magma.eval(code)
+        return magma.eval('s')
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+        
+
 
 # Matrix multiplication over GF(p)
 
@@ -346,17 +463,98 @@ s := Cputime(t);
         raise ValueError, 'unknown system "%s"'%system
     
 
+def rank_GF(n=500, p=16411, min=0, max=9, system='sage'):
+    """
+    Rank over GF:
+    Given a n x (n+10) (with n=500) matrix over ZZ with random entries
+    between min=0 and max=9, compute the rank.
+    """
+    if system == 'sage':
+        A = random_matrix(GF(p), n, n+10)
+        t = cputime()
+        v = A.rank()
+        return cputime(t)
+    elif system == 'magma':
+        code = """
+n := %s;
+A := Random(MatrixAlgebra(GF(%s), n));
+t := Cputime();
+K := Rank(A);
+s := Cputime(t);
+"""%(n,p)
+        if verbose: print code
+        magma.eval(code)
+        return float(magma.eval('s'))
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+
+def rank2_GF(n=500, p=16411, min=0, max=9, system='sage'):
+    """
+    Rank over GF(p):
+    Given a (n + 10) x n (with n=500) matrix over GF(p) with random entries
+    between min=0 and max=9, compute the rank.
+    """
+    if system == 'sage':
+        A = random_matrix(GF(p), n+10, n)
+        t = cputime()
+        v = A.rank()
+        return cputime(t)
+    elif system == 'magma':
+        code = """
+n := %s;
+A := Random(MatrixAlgebra(GF(%s), n));
+t := Cputime();
+K := Rank(A);
+s := Cputime(t);
+"""%(n,p)
+        if verbose: print code
+        magma.eval(code)
+        return float(magma.eval('s'))
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+
+def det_GF(n=400, p=16411 ,min=1, max=100, system='sage'):
+    """
+    Dense integer determinant over GF.
+    Given an n x n (with n=400) matrix A over GF with random entries
+    between min=1 and max=100, inclusive, compute det(A).
+    """
+    if system == 'sage':
+        A = random_matrix(GF(p), n, n, x=min, y=max+1)
+        t = cputime()
+        d = A.determinant()
+        return cputime(t)
+    elif system == 'magma':
+        code = """
+n := %s;
+A := Random(MatrixAlgebra(GF(%s), n));
+t := Cputime();
+d := Determinant(A);
+s := Cputime(t);
+"""%(n,p)
+        if verbose: print code
+        magma.eval(code)
+        return float(magma.eval('s'))
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+    
+
+
+
 
 #######################################################################
 # Dense Benchmarks over QQ
 #######################################################################
 
 def hilbert_matrix(n):
-  A = Matrix(QQ,n,n)
-  for i in range(A.nrows()):
-      for j in range(A.ncols()):
-          A[i,j] =  QQ(1)/((i+1)+(j+1)-1)
-  return A
+    """
+    Returns the Hilbert matrix of size n over rationals.
+    """
+    A = Matrix(QQ,n,n)
+    for i in range(A.nrows()):
+        for j in range(A.ncols()):
+            A[i,j] =  QQ(1)/((i+1)+(j+1)-1)  
+    return A
 
 # Reduced row echelon form over QQ
 
@@ -446,6 +644,10 @@ s := Cputime(t);
 
 # Determinant of Hilbert matrix
 def det_hilbert_QQ(n=80, system='sage'):
+    """
+    Runs the benchmark for calculating the determinant of the hilbert
+    matrix over rationals of dimension n.
+    """
     if system == 'sage':
         A = hilbert_matrix(n)
         t = cputime()
@@ -465,6 +667,10 @@ delete h;
 
 # inverse of Hilbert matrix
 def invert_hilbert_QQ(n=40, system='sage'):
+    """
+    Runs the benchmark for calculating the inverse of the hilbert
+    matrix over rationals of dimension n.
+    """
     if system == 'sage':
         A = hilbert_matrix(n)
         t = cputime()
@@ -482,3 +688,38 @@ delete h;
         magma.eval(code)
         return float(magma.eval('s'))
 
+
+#######################################################################
+# Dense Benchmarks over machine reals
+# Note that the precision in reals for MAGMA is base 10, while in
+# sage it is in base 2
+#######################################################################
+
+# Real Nullspace
+
+def nullspace_RR(n=300, min=0, max=10, system='sage'):
+    """
+    Nullspace over RR:
+    Given a n+1 x n (with n=300) matrix over RR with random entries
+    between min=0 and max=10, compute the nullspace.
+    """
+    if system == 'sage':
+        A = random_matrix(ZZ, n+1, n, x=min, y=max+1).change_ring(RR)
+        t = cputime()
+        v = A.kernel()
+        return cputime(t)
+    elif system == 'magma':
+        code = """
+n := %s;
+A := RMatrixSpace(RealField(16), n+1,n)![Random(%s,%s) : i in [1..n*(n+1)]];
+t := Cputime();
+K := Kernel(A);
+s := Cputime(t);
+"""%(n,min,max)
+        if verbose: print code
+        magma.eval(code)
+        return float(magma.eval('s'))
+    else:
+        raise ValueError, 'unknown system "%s"'%system
+        
+
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix0.pyx
--- a/sage/matrix/matrix0.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix0.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -39,9 +39,6 @@ import sage.modules.free_module
 import sage.modules.free_module
 
 import matrix_misc
-
-import strassen
-import matrix_window
 
 
 
@@ -1192,8 +1189,8 @@ cdef class Matrix(sage.structure.element
     ###################################################
     def linear_combination_of_rows(self, v):
         """
-        Return the linear combination of the rows of self given by the coefficients in
-        the list v.
+        Return the linear combination of the rows of self given by the
+        coefficients in the list v.
 
         INPUT:
             v -- list
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix1.pyx
--- a/sage/matrix/matrix1.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix1.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -218,8 +218,9 @@ cdef class Matrix(matrix0.Matrix):
 
     def matrix_over_field(self):
         """
-        Return this matrix, but with entries viewed as elements of the
-        fraction field of the base ring (assuming it is defined).
+        Return copy of this matrix, but with entries viewed as
+        elements of the fraction field of the base ring (assuming it
+        is defined).
 
         EXAMPLES:
             sage: A = MatrixSpace(IntegerRing(),2)([1,2,3,4])
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix2.pyx
--- a/sage/matrix/matrix2.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix2.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -16,15 +16,12 @@ include "../ext/stdsage.pxi"
 include "../ext/stdsage.pxi"
 include "../ext/python.pxi"
 
-import strassen
-
 from   sage.structure.sequence import _combinations, Sequence
 from   sage.misc.misc import verbose, get_verbose
 from   sage.rings.number_field.all import is_NumberField
 from   sage.rings.integer_ring import ZZ
 
 import sage.modules.free_module
-import matrix_window
 import matrix_space
 import berlekamp_massey
 from sage.modules.free_module_element import is_FreeModuleElement
@@ -1118,6 +1115,14 @@ cdef class Matrix(matrix1.Matrix):
         """
         return self.row_module()
 
+    def _row_ambient_module(self):
+        x = self.fetch('row_ambient_module')
+        if not x is None:
+            return x
+        x = sage.modules.free_module.FreeModule(self.base_ring(), self.ncols(), sparse=self.is_sparse())
+        self.cache('row_ambient_module',x)
+        return x
+
     def row_module(self):
         """
         Return the free module over the base ring spanned by the rows
@@ -1131,7 +1136,7 @@ cdef class Matrix(matrix1.Matrix):
             [1 0]
             [0 2]
         """
-        M = sage.modules.free_module.FreeModule(self.base_ring(), self.ncols(), sparse=self.is_sparse())
+        M = self._row_ambient_module()
         return M.span(self.rows())
 
     def row_space(self):
@@ -1151,6 +1156,15 @@ cdef class Matrix(matrix1.Matrix):
         """
         return self.row_module()
     
+
+    def _column_ambient_module(self):
+        x = self.fetch('column_ambient_module')
+        if not x is None:
+            return x
+        x = sage.modules.free_module.FreeModule(self.base_ring(), self.nrows(),
+                                                sparse=self.is_sparse())
+        self.cache('column_ambient_module',x)
+        return x
 
     def column_module(self):
         """
@@ -1737,10 +1751,9 @@ cdef class Matrix(matrix1.Matrix):
         base extend to the fraction field, if that is what you want. 
             sage: R.<x,y> = QQ[]
             sage: a = matrix(R, 2, [x,y,x,y])
-            sage: a.echelonize()
-            Traceback (most recent call last):
-            ...
-            ValueError: echelon form not implemented for elements of 'Full MatrixSpace of 2 by 2 dense matrices over Polynomial Ring in x, y over Rational Field'            
+            sage: a.echelon_form()
+            [  1 y/x]
+            [  0   0]
             sage: b = a.change_ring(R.fraction_field())
             sage: b.echelon_form()
             [  1 y/x]
@@ -1809,7 +1822,14 @@ cdef class Matrix(matrix1.Matrix):
         x = self.fetch('echelon_form')
         if not x is None:
             return x
-        E = self.copy()
+        R = self.base_ring()
+        if not (R == ZZ or R.is_field()):
+            try:
+                E = self.matrix_over_field()
+            except TypeError:
+                raise NotImplementedError, "Echelon form not implemented over '%s'."%R
+        else:
+            E = self.copy()
         if algorithm == 'default':
             E.echelonize(cutoff=cutoff)
         else:
@@ -1849,9 +1869,9 @@ cdef class Matrix(matrix1.Matrix):
         cdef Py_ssize_t start_row, c, r, nr, nc, i
         if self.fetch('in_echelon_form'):
             return
-        
+
         self.check_mutability()
-        cdef Matrix d
+        cdef Matrix A, d
 
         nr = self._nrows
         nc = self._ncols
@@ -1866,8 +1886,9 @@ cdef class Matrix(matrix1.Matrix):
                 self.cache('pivots', d.pivots())
                 return 
             else:
-                raise ValueError, "echelon form not implemented for elements of '%s'"%self.parent()
-
+                A = self.matrix_over_field()
+        else:
+            A = self
         
         start_row = 0
         pivots = []
@@ -1875,21 +1896,24 @@ cdef class Matrix(matrix1.Matrix):
         for c from 0 <= c < nc:
             if PyErr_CheckSignals(): raise KeyboardInterrupt
             for r from start_row <= r < nr:
-                if self.get_unsafe(r, c) != 0:
+                if A.get_unsafe(r, c) != 0:
                     pivots.append(c)
-                    a_inverse = ~self.get_unsafe(r,c)
-                    self.rescale_row(r, a_inverse, c)
-                    self.swap_rows(r, start_row)
+                    a_inverse = ~A.get_unsafe(r,c)
+                    A.rescale_row(r, a_inverse, c)
+                    A.swap_rows(r, start_row)
                     for i from 0 <= i < nr:
                         if i != start_row:
-                            if self.get_unsafe(i,c) != 0:
-                                minus_b = -self.get_unsafe(i, c)
-                                self.add_multiple_of_row(i, start_row, minus_b, c)
+                            if A.get_unsafe(i,c) != 0:
+                                minus_b = -A.get_unsafe(i, c)
+                                A.add_multiple_of_row(i, start_row, minus_b, c)
                     start_row = start_row + 1
                     break
         self.cache('pivots', pivots)
-        self.cache('in_echelon_form', True)
-        verbose('done with gauss', tm)
+        A.cache('pivots', pivots)
+        A.cache('in_echelon_form', True)
+        self.cache('echelon_form', A)
+
+        verbose('done with gauss echelon form', tm)
 
     #####################################################################################
     # Windowed Strassen Matrix Multiplication and Echelon
@@ -1932,7 +1956,9 @@ cdef class Matrix(matrix1.Matrix):
         self_window   = self.matrix_window()
         right_window  = right.matrix_window()
         output_window = output.matrix_window()
-        
+
+
+        import strassen
         strassen.strassen_window_multiply(output_window, self_window, right_window, cutoff)
         return output
 
@@ -1969,7 +1995,8 @@ cdef class Matrix(matrix1.Matrix):
         if self._nrows < cutoff or self._ncols < cutoff:
             self._echelon_in_place_classical()
             return
-            
+        
+        import strassen            
         pivots = strassen.strassen_echelon(self.matrix_window(), cutoff)
         self._set_pivots(pivots)
         verbose('done with strassen', tm)
@@ -1991,6 +2018,7 @@ cdef class Matrix(matrix1.Matrix):
     
     cdef matrix_window_c(self, Py_ssize_t row, Py_ssize_t col,
                          Py_ssize_t nrows, Py_ssize_t ncols):
+        import matrix_window
         if nrows == -1:
             nrows = self._nrows - row
             ncols = self._ncols - col
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix_integer_dense.pyx
--- a/sage/matrix/matrix_integer_dense.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix_integer_dense.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -32,6 +32,8 @@ EXAMPLES:
 #                  http://www.gnu.org/licenses/
 ######################################################################
 
+from sage.modules.vector_integer_dense cimport Vector_integer_dense
+
 from sage.misc.misc import verbose, get_verbose, cputime
 
 include "../ext/interrupt.pxi"
@@ -48,13 +50,13 @@ from sage.rings.integer_ring import ZZ
 from sage.rings.integer_ring import ZZ
 from sage.rings.integer_mod_ring import IntegerModRing
 from sage.rings.polynomial_ring import PolynomialRing
-from sage.structure.element cimport ModuleElement, RingElement, Element
+from sage.structure.element cimport ModuleElement, RingElement, Element, Vector
 
 from matrix_modn_dense import Matrix_modn_dense
 from matrix_modn_dense cimport Matrix_modn_dense
 
 import sage.modules.free_module
-
+import sage.modules.free_module_element
 
 from matrix cimport Matrix
 
@@ -71,7 +73,7 @@ linbox = Linbox_integer_dense()
 
 # Off since it is still flakie on some platforms (e.g., 64-bit linux,
 # 32-bit debian linux, etc.)
-USE_LINBOX_POLY = False
+USE_LINBOX_POLY = True
 
 cdef class Matrix_integer_dense(matrix_dense.Matrix_dense):   # dense or sparse
     r"""
@@ -121,7 +123,6 @@ cdef class Matrix_integer_dense(matrix_d
         WARNING: This is for internal use only, or if you really know what you're doing.
         """
         matrix_dense.Matrix_dense.__init__(self, parent)
-        self._initialized = 0
         self._nrows = parent.nrows()
         self._ncols = parent.ncols()
         self._pivots = None
@@ -163,22 +164,22 @@ cdef class Matrix_integer_dense(matrix_d
         for i from 0 <= i < self._nrows * self._ncols:
             mpz_init_set(A._entries[i], self._entries[i])
         _sig_off
+        A._initialized = True
         return A
     
-    def  __dealloc__(self):
+    def __dealloc__(self):
         """
         Frees all the memory allocated for this matrix. 
         EXAMPLE:
             sage: a = Matrix(ZZ,2,[1,2,3,4])
             sage: del a        
         """
-        if self._entries == NULL: return
         cdef Py_ssize_t i
         if self._initialized:
             for i from 0 <= i < (self._nrows * self._ncols):
                 mpz_clear(self._entries[i])
-        sage_free(self._entries)
-        sage_free(self._matrix)
+            sage_free(self._entries)
+            sage_free(self._matrix)
 
     def __init__(self, parent, entries, copy, coerce):
         r"""
@@ -240,7 +241,7 @@ cdef class Matrix_integer_dense(matrix_d
         cdef int is_list
         cdef Integer x
 
-        if not isinstance(entries, list):  # todo -- change to PyObject_TypeCheck???
+        if not isinstance(entries, list): 
             try:
                 entries = list(entries)
                 is_list = 1
@@ -258,6 +259,9 @@ cdef class Matrix_integer_dense(matrix_d
 
             # Create the matrix whose entries are in the given entry list.
             if len(entries) != self._nrows * self._ncols:
+                sage_free(self._entries)
+                sage_free(self._matrix)
+                self._entries = NULL
                 raise TypeError, "entries has the wrong length"
             if coerce:
                 for i from 0 <= i < self._nrows * self._ncols:
@@ -266,11 +270,12 @@ cdef class Matrix_integer_dense(matrix_d
                     # todo -- see integer.pyx and the TODO there; perhaps this could be
                     # sped up by creating a mpz_init_set_sage function.
                     mpz_init_set(self._entries[i], x.value)
+                self._initialized = True
             else:
                 for i from 0 <= i < self._nrows * self._ncols:
                     # TODO: Should use an unsafe un-bounds-checked array access here.
                     mpz_init_set(self._entries[i], (<Integer> entries[i]).value)
-                    
+                self._initialized = True                    
         else:
 
             # If x is zero, make the zero matrix and be done.
@@ -291,8 +296,7 @@ cdef class Matrix_integer_dense(matrix_d
             for i from 0 <= i < self._nrows:
                 mpz_init_set(self._entries[j], x.value)
                 j = j + self._nrows + 1
-            self._initialized = 1                        
-
+            self._initialized = True                    
 
     cdef set_unsafe(self, Py_ssize_t i, Py_ssize_t j, value):
         """
@@ -401,6 +405,7 @@ cdef class Matrix_integer_dense(matrix_d
             s = data[i]
             if mpz_init_set_str(self._entries[i], s, 32):
                 raise RuntimeError, "invalid pickle data"
+        self._initialized = True                                
 
 
     def __richcmp__(Matrix self, right, int op):  # always need for mysterious reasons.
@@ -426,7 +431,7 @@ cdef class Matrix_integer_dense(matrix_d
         for i from 0 <= i < self._nrows * self._ncols:
             mpz_init(self._entries[i])
         _sig_off
-        self._initialized = 1
+        self._initialized = True                            
 
     cdef _new_unitialized_matrix(self, Py_ssize_t nrows, Py_ssize_t ncols):
         """
@@ -535,36 +540,23 @@ cdef class Matrix_integer_dense(matrix_d
         _sig_off
         mpz_clear(s)
         mpz_clear(z)
+        M._initialized = True
         return M
 
     cdef sage.structure.element.Matrix _matrix_times_matrix_c_impl(self, sage.structure.element.Matrix right):
-        
-        return self._multiply_classical(right)
-    
-        # NOTE -- the multimodular matrix multiply implementation
-        # breaks on 64-bit machines; e..g, the following doctests
-        # *all* fail if multimodular matrix multiply is enabled
-        # on sage.math.washington.edu:
-        
-        #sage -t  devel/sage-main/sage/modular/modsym/modsym.py
-        #sage -t  devel/sage-main/sage/modular/modsym/space.py
-        #sage -t  devel/sage-main/sage/modular/modsym/subspace.py
-        #sage -t  devel/sage-main/sage/modular/hecke/hecke_operator.py
-        #sage -t  devel/sage-main/sage/modular/hecke/module.py
-
         #############
         # see the tune_multiplication function below.
         n = max(self._nrows, self._ncols, right._nrows, right._ncols)
         if n <= 20:
             return self._multiply_classical(right)
-        return self._multiply_multi_modular(right)
-##         a = self.height(); b = right.height()
-##         # waiting for multiply_multi_modular to get fixed, and not assume all matrix entries
-##         # are between 0 and prod - 1.
-##         if float(max(a,b)) / float(n) >= 0.70:
-##             return self._multiply_classical(right)
-##         else:
-##             return self._multiply_multi_modular(right)
+        a = self.height(); b = right.height()
+        # waiting for multiply_multi_modular to get fixed, and not assume all matrix entries
+        # are between 0 and prod - 1.
+        if float(max(a,b)) / float(n) >= 0.70:
+            return self._multiply_classical(right)
+        else:
+            return self._multiply_multi_modular(right)
+        
 
     cdef ModuleElement _lmul_c_impl(self, RingElement right):
         """
@@ -582,7 +574,7 @@ cdef class Matrix_integer_dense(matrix_d
         for i from 0 <= i < self._nrows * self._ncols:
             mpz_init(M._entries[i])
             mpz_mul(M._entries[i], self._entries[i], _x.value)
-        M._initialized = 1
+        M._initialized = True
         return M
 
     cdef ModuleElement _add_c_impl(self, ModuleElement right):
@@ -602,20 +594,22 @@ cdef class Matrix_integer_dense(matrix_d
             [ 9 11 13]
             [ 9 11 13]
         """
-        cdef Py_ssize_t i
+        cdef Py_ssize_t i, j
         
         cdef Matrix_integer_dense M
         M = Matrix_integer_dense.__new__(Matrix_integer_dense, self._parent, None, None, None)
-        Matrix.__init__(M, self._parent)
 
         _sig_on
-
-        cdef mpz_t *entries
-        entries = M._entries
-        for i from 0 <= i < self._ncols * self._nrows:
-            mpz_init(entries[i])
-            mpz_add(entries[i], self._entries[i], (<Matrix_integer_dense> right)._entries[i])
+        cdef mpz_t *row_self, *row_right, *row_ans
+        for i from 0 <= i < self._nrows:
+            row_self = self._matrix[i]
+            row_right = (<Matrix_integer_dense> right)._matrix[i]
+            row_ans = M._matrix[i]
+            for j from 0 <= j < self._ncols:
+                mpz_init(row_ans[j])
+                mpz_add(row_ans[j], row_self[j], row_right[j])
         _sig_off
+        M._initialized = True        
         return M
 
     cdef ModuleElement _sub_c_impl(self, ModuleElement right):
@@ -629,26 +623,26 @@ cdef class Matrix_integer_dense(matrix_d
             [-8 -6 -4]
             [-2  0  2]
             [ 4  6  8]
-        
-        """
-        cdef Py_ssize_t i
+        """
+        cdef Py_ssize_t i, j
         
         cdef Matrix_integer_dense M
         M = Matrix_integer_dense.__new__(Matrix_integer_dense, self._parent, None, None, None)
-        Matrix.__init__(M, self._parent)
 
         _sig_on
-
-        cdef mpz_t *entries
-        entries = M._entries
-        for i from 0 <= i < self._ncols * self._nrows:
-            mpz_init(entries[i])
-            mpz_sub(entries[i], self._entries[i], (<Matrix_integer_dense> right)._entries[i])
-
+        cdef mpz_t *row_self, *row_right, *row_ans
+        for i from 0 <= i < self._nrows:
+            row_self = self._matrix[i]
+            row_right = (<Matrix_integer_dense> right)._matrix[i]
+            row_ans = M._matrix[i]
+            for j from 0 <= j < self._ncols:
+                mpz_init(row_ans[j])
+                mpz_sub(row_ans[j], row_self[j], row_right[j])
         _sig_off
+        M._initialized = True        
         return M
-        
-
+
+        
     cdef int _cmp_c_impl(self, Element right) except -2:
         cdef mpz_t *a, *b
         cdef Py_ssize_t i, j
@@ -665,7 +659,50 @@ cdef class Matrix_integer_dense(matrix_d
                         return 1
         return 0
 
+    def is_zero(self):
+        cdef mpz_t *a, *b
+        cdef Py_ssize_t i, j
+        cdef int k
+        for i from 0 <= i < self._nrows * self._ncols:
+            if mpz_cmp_si(self._entries[i], 0):
+                return False
+        return True
     
+    cdef Vector _vector_times_matrix_c_impl(self, Vector v):
+        """
+        Returns the vector times matrix product.
+
+        INPUT:
+             v -- a free module element.
+
+        OUTPUT:
+            The the vector times matrix product v*A.
+
+        EXAMPLES:
+            sage: B = matrix(ZZ,2, [1,2,3,4])
+            sage: V = ZZ^2
+            sage: w = V([-1,5])
+            sage: w*B
+            (14, 18)
+        """
+        cdef Vector_integer_dense w, ans
+        cdef Py_ssize_t i, j
+        cdef mpz_t x
+        
+        M = self._row_ambient_module()
+        w = <Vector_integer_dense> v
+        ans = M.zero_vector()
+        
+        mpz_init(x)
+        for i from 0 <= i < self._ncols:
+            mpz_set_si(x, 0)
+            for j from 0 <= j < self._nrows:
+                mpz_addmul(x, w._entries[j], self._matrix[j][i])
+            mpz_set(ans._entries[i], x)
+        mpz_clear(x)
+        return ans
+
+
     ########################################################################
     # LEVEL 3 functionality (Optional)
     #    * cdef _sub_c_impl
@@ -750,10 +787,15 @@ cdef class Matrix_integer_dense(matrix_d
         self.cache(key, g)
         return g
 
+    
+
     def _minpoly_linbox(self, var='x'):
         return self._poly_linbox(var=var, typ='minpoly')
 
     def _charpoly_linbox(self, var='x'):
+        if self.is_zero():  # program around a bug in linbox on 32-bit linux
+            x = self.base_ring()[var].gen()
+            return x ** self._nrows
         return self._poly_linbox(var=var, typ='charpoly')
 
     def _poly_linbox(self, var='x', typ='minpoly'):
@@ -768,12 +810,14 @@ cdef class Matrix_integer_dense(matrix_d
         if self._nrows <= 1:
             return matrix_dense.Matrix_dense.charpoly(self, var)
         self._init_linbox()
-        _sig_on
         if typ == 'minpoly':
+            _sig_on
             v = linbox.minpoly()
+            _sig_off
         else:
+            _sig_on
             v = linbox.charpoly()
-        _sig_off
+            _sig_off
         R = self._base_ring[var]
         verbose('finished computing %s'%typ, time)
         return R(v)
@@ -844,7 +888,7 @@ cdef class Matrix_integer_dense(matrix_d
         cdef mod_int *moduli
         cdef int i, n, k
 
-        h = left.height() * right.height()
+        h = left.height() * right.height() * left._ncols
         mm = MultiModularBasis(h)
         res = left._reduce(mm)
         res_right = right._reduce(mm)
@@ -1371,21 +1415,21 @@ cdef class Matrix_integer_dense(matrix_d
         
     def _linbox_sparse(self):
         cdef Py_ssize_t i, j
-        s = '%s %s +\n'%(self._nrows, self._ncols)
+        v = ['%s %s M'%(self._nrows, self._ncols)]
         for i from 0 <= i < self._nrows:
             for j from 0 <= j < self._ncols:
                 if mpz_cmp_si(self._matrix[i][j], 0):
-                    s += '%s %s %s\n'%(i+1,j+1,self.get_unsafe(i,j))
-        s += '0 0 0\n'
-        return s
+                    v.append('%s %s %s'%(i+1,j+1,self.get_unsafe(i,j)))
+        v.append('0 0 0\n')
+        return '\n'.join(v)
                 
     def _linbox_dense(self):
         cdef Py_ssize_t i, j
-        s = '%s %s x'%(self._nrows, self._ncols)
+        v = ['%s %s x'%(self._nrows, self._ncols)]
         for i from 0 <= i < self._nrows:
             for j from 0 <= j < self._ncols:
-                s += ' %s'%self.get_unsafe(i,j)
-        return s
+                v.append(str(self.get_unsafe(i,j)))
+        return ' '.join(v)
 
     def rational_reconstruction(self, N):
         """
@@ -1446,7 +1490,7 @@ cdef class Matrix_integer_dense(matrix_d
                     k = random()%nc
                     mpz_urandomm(self._matrix[i][k], state, n_width.value)
                     if min_is_nonzero:                    
-                        mpz_add(self._matrix[i][k], self._matrix[i][j], n_min.value)
+                        mpz_add(self._matrix[i][k], self._matrix[i][k], n_min.value)
         _sig_off
 
     #### Rank
@@ -1572,7 +1616,7 @@ def _lift_crt(Matrix_integer_dense M, re
     res = FAST_SEQ_UNSAFE(residues)
 
     cdef mod_int **row_list
-    row_list = <mod_int**>sage_malloc(sizeof(mod_int*) * n)
+    row_list = <mod_int**>sage_malloc(sizeof(mod_int) * n)
     if row_list == NULL:
         raise MemoryError, "out of memory allocating multi-modular coefficent list"
     
@@ -1593,7 +1637,7 @@ cdef extern from "stdlib.h":
 cdef extern from "stdlib.h":
     long random()
     void srandom(unsigned int seed)
-k = randrange(0,2**32)
+k = randrange(0,Integer(2)**(32))
 srandom(k)
 
 cdef gmp_randstate_t state
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix_modn_dense.pxd
--- a/sage/matrix/matrix_modn_dense.pxd	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix_modn_dense.pxd	Fri Feb 23 15:16:47 2007 -0800
@@ -2,7 +2,6 @@ cimport matrix_dense
 
 cdef extern from "../ext/multi_modular.h":
     ctypedef unsigned long mod_int
-    mod_int MOD_INT_MAX
     mod_int MOD_INT_OVERFLOW
 
 cdef class Matrix_modn_dense(matrix_dense.Matrix_dense):
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix_modn_dense.pyx
--- a/sage/matrix/matrix_modn_dense.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix_modn_dense.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -76,15 +76,19 @@ include '../ext/stdsage.pxi'
 include '../ext/stdsage.pxi'
 include '../ext/random.pxi'
     
-MAX_MODULUS = 46340
+import sage.ext.multi_modular
+MAX_MODULUS = sage.ext.multi_modular.MAX_MODULUS
 
 import matrix_window_modn_dense
 
 from sage.rings.arith import is_prime
+from sage.structure.element cimport ModuleElement
 
 cimport matrix_dense
 cimport matrix
 cimport matrix0
+cimport sage.structure.element
+
 
 from sage.libs.linbox.linbox cimport Linbox_modn_dense
 cdef Linbox_modn_dense linbox
@@ -93,8 +97,6 @@ from sage.structure.element cimport Matr
 from sage.structure.element cimport Matrix
 
 from sage.rings.integer_mod cimport IntegerMod_int, IntegerMod_abstract
-
-from sage.structure.element import ModuleElement
 
 from sage.misc.misc import verbose, get_verbose, cputime
 
@@ -113,7 +115,6 @@ ai = arith_int()
 #  The full text of the GPL is available at:
 #                  http://www.gnu.org/licenses/
 ##############################################################################
-
 
 cdef class Matrix_modn_dense(matrix_dense.Matrix_dense):  
     ########################################################################
@@ -132,8 +133,8 @@ cdef class Matrix_modn_dense(matrix_dens
         cdef mod_int p
         p = self._base_ring.characteristic()
         self.p = p
-        if p >= MOD_INT_MAX:
-            raise OverflowError, "p (=%s) must be < %s"%(p, MOD_INT_MAX)
+        if p >= MAX_MODULUS:
+            raise OverflowError, "p (=%s) must be < %s"%(p, MAX_MODULUS)
         self.gather = MOD_INT_OVERFLOW/(p*p)
 
         _sig_on
@@ -254,7 +255,58 @@ cdef class Matrix_modn_dense(matrix_dens
         A.gather = self.gather
         return A
 
+
+    cdef ModuleElement _add_c_impl(self, ModuleElement right):
+        """
+        Add two dense matrices over Z/nZ
+
+        EXAMPLES:
+            sage: a = MatrixSpace(GF(19),3)(range(9))
+            sage: a+a
+            [ 0  2  4]
+            [ 6  8 10]
+            [12 14 16]
+            sage: b = MatrixSpace(GF(19),3)(range(9))
+            sage: b.swap_rows(1,2)
+            sage: a+b
+            [ 0  2  4]
+            [ 9 11 13]
+            [ 9 11 13]
+            sage: b+a
+            [ 0  2  4]
+            [ 9 11 13]
+            [ 9 11 13]
+        """
+        
+        cdef Py_ssize_t i,j
+        cdef long k
+        cdef Matrix_modn_dense M 
+
+        M = Matrix_modn_dense.__new__(Matrix_modn_dense, self._parent,None,None,None)
+        Matrix.__init__(M, self._parent)
+        
+        _sig_on 
+        cdef mod_int *row_self, *row_right, *row_ans
+        for i from 0 <= i < self._nrows:
+            row_self = self._matrix[i]
+            row_right = (<Matrix_modn_dense> right)._matrix[i]
+            row_ans = M._matrix[i]
+            for j from 0<= j < self._ncols:
+                k = (row_self[j]+row_right[j])
+                # division is really slow, so we normalize only when it is necessary
+                if k>self.p:
+                    row_ans[j]=k-self.p
+                else:
+                    row_ans[j]=k
+                
+        _sig_off
+        return M;
+
+
     cdef Matrix _matrix_times_matrix_c_impl(self, Matrix right):
+        if get_verbose() >= 2:
+            verbose('mod-p multiply of %s x %s matrix by %s x %s matrix modulo %s'%(
+                self._nrows, self._ncols, right._nrows, right._ncols, self.p))
         if self._will_use_strassen(right):
             return self._multiply_strassen(right)
         else:
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix_space.py
--- a/sage/matrix/matrix_space.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix_space.py	Fri Feb 23 15:16:47 2007 -0800
@@ -424,7 +424,7 @@ class MatrixSpace_generic(parent_gens.Pa
             return matrix_generic_dense.Matrix_generic_dense
         
         else:            
-            if sage.rings.integer_mod_ring.is_IntegerModRing(R) and R.order() < matrix_modn_dense.MAX_MODULUS:
+            if sage.rings.integer_mod_ring.is_IntegerModRing(R) and R.order() < 46340: # matrix_modn_dense.MAX_MODULUS:
                 return matrix_modn_sparse.Matrix_modn_sparse
             # the default
             return matrix_generic_sparse.Matrix_generic_sparse
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix_window_modn_dense.pxd
--- a/sage/matrix/matrix_window_modn_dense.pxd	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix_window_modn_dense.pxd	Fri Feb 23 15:16:47 2007 -0800
@@ -2,7 +2,6 @@ from matrix_window cimport MatrixWindow
 
 cdef extern from "../ext/multi_modular.h":
     ctypedef unsigned long mod_int
-    mod_int MOD_INT_MAX
 
 cdef class MatrixWindow_modn_dense(MatrixWindow):
     pass
\ No newline at end of file
diff -r c62f94993946 -r a7ec047172ff sage/matrix/matrix_window_modn_dense.pyx
--- a/sage/matrix/matrix_window_modn_dense.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/matrix_window_modn_dense.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -24,21 +24,19 @@ cdef class MatrixWindow_modn_dense(matri
         cdef Py_ssize_t i, j
         if self._nrows != A._nrows or self._ncols != A._ncols:
             raise ArithmeticError, "incompatible dimensions"
-        cdef mod_int* self_row
-        cdef mod_int* A_row
-        for i from 0 <= i < self._nrows:
-            self_row = ( <Matrix_modn_dense> self._matrix )._matrix[i + self._row] + self._col
-            A_row    = ( <Matrix_modn_dense>    A._matrix )._matrix[i +    A._row] + A._col
-            for j from 0 <= j < self._ncols:
-                self_row[j] = A_row[j]
-#            memcpy(self_rows[i+self._row] + self._col, A_rows[i+A._row] + A._col, self._ncols * sizeof(mod_int*))
+        cdef mod_int** self_rows
+        cdef mod_int** A_rows
+        self_rows = ( <Matrix_modn_dense> self._matrix )._matrix
+        A_rows    = ( <Matrix_modn_dense> A._matrix )._matrix
+        for i from 0 <= i < self._nrows:
+            memcpy(self_rows[i+self._row] + self._col, A_rows[i+A._row] + A._col, self._ncols * sizeof(mod_int))
                 
     cdef set_to_zero(MatrixWindow_modn_dense self):
         cdef Py_ssize_t i, j
         cdef mod_int** rows
         rows = ( <Matrix_modn_dense> self._matrix )._matrix
         for i from self._row <= i < self._row + self._nrows:
-            memset(rows[i] + self._col, 0, self._ncols * sizeof(mod_int*))
+            memset(rows[i] + self._col, 0, self._ncols * sizeof(mod_int))
 
     cdef add(self, MatrixWindow A):
         cdef Py_ssize_t i, j
diff -r c62f94993946 -r a7ec047172ff sage/matrix/misc.pyx
--- a/sage/matrix/misc.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/matrix/misc.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -234,3 +234,8 @@ def cmp_pivots(x,y):
     else:
         return -1
     
+
+
+#######################################3
+
+    
diff -r c62f94993946 -r a7ec047172ff sage/modules/free_module.py
--- a/sage/modules/free_module.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/modules/free_module.py	Fri Feb 23 15:16:47 2007 -0800
@@ -64,7 +64,7 @@ Base ring:
 """
 
 ####################################################################################
-#       Copyright (C) 2005 William Stein <wstein@gmail.com>
+#       Copyright (C) 2005, 2007 William Stein <wstein@gmail.com>
 #
 #  Distributed under the terms of the GNU General Public License (GPL)
 #
@@ -173,7 +173,8 @@ def FreeModule(base_ring, rank, sparse=F
     The default is dense.
         sage: M = ZZ^200
         sage: type(M.0)
-        <type 'sage.modules.free_module_element.FreeModuleElement_generic_dense'>
+        <type 'sage.modules.vector_integer_dense.Vector_integer_dense'>
+
 
     Note that matrices associated in some way to sparse free modules
     are sparse by default:
@@ -339,23 +340,23 @@ class FreeModule_generic(module.Module):
         if degree < 0:
             raise ValueError, "degree (=%s) must be nonnegative"%degree
         
+        ParentWithGens.__init__(self, base_ring)     # names aren't used anywhere.
         self.__uses_ambient_inner_product = True
         self.__rank = rank
         self.__degree = degree
         self.__is_sparse = sparse
         self._inner_product_matrix = inner_product_matrix
         self.element_class()
-        ParentWithGens.__init__(self, base_ring)     # names aren't used anywhere.
+
+    def _an_element_impl(self):
+        return self.zero_vector()
 
     def element_class(self):
         try:
             return self._element_class
         except AttributeError:
             pass
-        if self.__is_sparse:
-            C = free_module_element.FreeModuleElement_generic_sparse
-        else:
-            C = free_module_element.FreeModuleElement_generic_dense
+        C = element_class(self.base_ring(), self.is_sparse())        
         self._element_class = C
         return C
     
@@ -2599,7 +2600,12 @@ class FreeModule_submodule_with_basis_pi
                             ambient.is_sparse(), inner_product_matrix=inner_product_matrix)
 
         C = self.element_class()
-        w = [C(self, x.list(),
+        try:
+            w = [C(self, x.list(),
+                          coerce=False, copy=True) for x in basis]
+        except TypeError:
+            C = element_class(R.fraction_field(), self.is_sparse())
+            w = [C(self, x.list(),
                           coerce=False, copy=True) for x in basis]
 
         self.__basis = basis_seq(self, w)
@@ -3485,3 +3491,18 @@ class ComplexDoubleVectorSpace_class(Fre
 
     def coordinates(self,v):
         return v
+
+
+
+######################################################
+
+def element_class(R, is_sparse):
+    if sage.rings.integer_ring.is_IntegerRing(R) and not is_sparse:
+        from vector_integer_dense import Vector_integer_dense
+        return Vector_integer_dense
+    else:
+        if is_sparse:
+            return free_module_element.FreeModuleElement_generic_sparse
+        else:
+            return free_module_element.FreeModuleElement_generic_dense
+    raise NotImplementedError
diff -r c62f94993946 -r a7ec047172ff sage/modules/free_module_element.pxd
--- a/sage/modules/free_module_element.pxd	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/modules/free_module_element.pxd	Fri Feb 23 15:16:47 2007 -0800
@@ -1,6 +1,7 @@ from sage.structure.element cimport Vect
 from sage.structure.element cimport Vector
 
 cdef class FreeModuleElement(Vector):
+    cdef int _is_mutable
     cdef int _cmp_same_ambient_c(left, FreeModuleElement right)
 
 cdef class FreeModuleElement_generic_dense(FreeModuleElement):
diff -r c62f94993946 -r a7ec047172ff sage/modules/free_module_element.pyx
--- a/sage/modules/free_module_element.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/modules/free_module_element.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -54,6 +54,14 @@ following is defined, and the result is 
     Vector space of dimension 5 over Finite Field of size 7
     sage: parent(M.0 + K.0)
     Vector space of dimension 5 over Finite Field of size 7
+
+Matrix vector multiply:
+    sage: MS = MatrixSpace(QQ,3)
+    sage: A = MS([0,1,0,1,0,0,0,0,1])
+    sage: V = QQ^3
+    sage: v = V([1,2,3])
+    sage: v * A
+    (2, 1, 3)
 """
 
 import operator
@@ -71,12 +79,13 @@ from sage.structure.sequence import Sequ
 from sage.structure.sequence import Sequence
 
 from sage.structure.element cimport Element, ModuleElement, RingElement, Vector as element_Vector
-from sage.matrix.matrix cimport Matrix
 
 import sage.rings.arith
 
 from sage.rings.ring import is_Ring
 import sage.rings.integer_ring
+
+#from sage.matrix.matrix cimport Matrix
 
 def is_FreeModuleElement(x):
     return isinstance(x, FreeModuleElement)
@@ -202,6 +211,7 @@ cdef class FreeModuleElement(element_Vec
     def __init__(self, parent):
         self._parent = parent
         self._degree = parent.degree()
+        self._is_mutable = 1
 
     def _vector_(self, R):
         return self.change_ring(R)
@@ -432,28 +442,8 @@ cdef class FreeModuleElement(element_Vec
     cdef int _cmp_same_ambient_c(left, FreeModuleElement right):
         return cmp(left.list(copy=False), right.list(copy=False))
     
-    def _matrix_multiply(self, Matrix A):
-        """
-        Return the product self*A.
-
-        EXAMPLES:
-            sage: MS = MatrixSpace(QQ,3)
-            sage: A = MS([0,1,0,1,0,0,0,0,1])
-            sage: V = QQ^3
-            sage: v = V([1,2,3])
-            sage: v._matrix_multiply(A)
-            (2, 1, 3)
-
-        The multiplication operator also just calls \code{_matrix_multiply}:
-            sage: v*A
-            (2, 1, 3)
-        """
-        return self*A
-
     cdef ModuleElement _rmul_nonscalar_c_impl(left, right):
-        if PY_TYPE_CHECK(right, Matrix):
-            return right.vector_matrix_multiply(left)
-        raise TypeError
+         raise TypeError
 
     def degree(self):
         return self._degree
@@ -602,12 +592,15 @@ cdef class FreeModuleElement(element_Vec
             s = s[:-1]  # get rid of last comma
         return s + '\\right)'
         
-            
 
 #############################################
 # Generic dense element
-#############################################  
+#############################################
 def make_FreeModuleElement_generic_dense(parent, entries, degree):
+    # If you think you want to change this function, don't.
+    # Instead make a new version with a name like
+    #    make_FreeModuleElement_generic_dense_v1
+    # and changed the reduce method below.
     cdef FreeModuleElement_generic_dense v
     v = FreeModuleElement_generic_dense.__new__(FreeModuleElement_generic_dense)
     v._entries = entries
@@ -723,7 +716,7 @@ cdef class FreeModuleElement_generic_den
         v = [None]*n
         for i from 0 <= i < n:
             v[i] = (<RingElement>left._entries[i])._mul_c((<FreeModuleElement_generic_dense>right)._entries[i])
-        return self._new_c(v)
+        return left._new_c(v)
 
     def __reduce__(self):
         return (make_FreeModuleElement_generic_dense, (self._parent, self._entries, self._degree))
@@ -794,6 +787,7 @@ cdef class FreeModuleElement_generic_den
         module element are equal if their coefficients are the same.
         """
         return cmp(left._entries, (<FreeModuleElement_generic_dense>right)._entries)
+
 
 
 #############################################
@@ -1028,3 +1022,5 @@ cdef class FreeModuleElement_generic_spa
         K.sort()
         return K
 
+
+
diff -r c62f94993946 -r a7ec047172ff sage/modules/vector_integer_dense.pxd
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/modules/vector_integer_dense.pxd	Fri Feb 23 15:16:47 2007 -0800
@@ -0,0 +1,10 @@
+cimport free_module_element
+import  free_module_element
+
+include '../ext/cdefs.pxi'
+
+cdef class Vector_integer_dense(free_module_element.FreeModuleElement):
+	cdef mpz_t* _entries
+	cdef _new_c(self)
+	cdef _init(self, Py_ssize_t degree, parent)
+	
diff -r c62f94993946 -r a7ec047172ff sage/modules/vector_integer_dense.pyx
--- /dev/null	Thu Jan 01 00:00:00 1970 +0000
+++ b/sage/modules/vector_integer_dense.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -0,0 +1,228 @@
+"""
+Vectors with integer entries
+
+AUTHOR:
+    -- William Stein (2007)
+
+EXAMPLES:
+    sage: v = vector(ZZ,[1,2,3,4,5])
+    sage: v
+    (1, 2, 3, 4, 5)
+    sage: 3*v
+    (3, 6, 9, 12, 15)
+    sage: v*7
+    (7, 14, 21, 28, 35)
+    sage: -v
+    (-1, -2, -3, -4, -5)
+    sage: v - v
+    (0, 0, 0, 0, 0)
+    sage: v + v
+    (2, 4, 6, 8, 10)
+    sage: v * v
+    (1, 4, 9, 16, 25)
+
+We make a large zero vector:
+    sage: k = ZZ^100000; k
+    Ambient free module of rank 100000 over the principal ideal domain Integer Ring
+    sage: v = k(0)
+    sage: v[:10]
+    (0, 0, 0, 0, 0, 0, 0, 0, 0, 0)
+"""
+
+###############################################################################
+#   SAGE: System for Algebra and Geometry Experimentation    
+#       Copyright (C) 2007 William Stein <wstein@gmail.com>
+#  Distributed under the terms of the GNU General Public License (GPL)
+#                  http://www.gnu.org/licenses/
+###############################################################################
+
+include '../ext/interrupt.pxi'
+include '../ext/stdsage.pxi'
+
+from sage.structure.element cimport Element, ModuleElement, RingElement, Vector
+
+from sage.rings.integer cimport Integer
+
+cimport free_module_element
+
+
+cdef class Vector_integer_dense(free_module_element.FreeModuleElement):
+    cdef _new_c(self):
+        cdef Vector_integer_dense y
+        y = PY_NEW(Vector_integer_dense)
+        y._init(self._degree, self._parent)
+        return y
+
+    def __copy__(self):
+        cdef Vector_integer_dense y
+        y = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init_set(y._entries[i], self._entries[i])
+        return y
+
+    cdef _init(self, Py_ssize_t degree, parent):
+        self._degree = degree
+        self._parent = parent
+        self._entries = <mpz_t *> sage_malloc(sizeof(mpz_t) * degree)
+        if self._entries == NULL:
+            raise MemoryError
+        
+    def __new__(self, parent=None, x=None, coerce=True,copy=True):
+        self._entries = NULL
+        if not parent is None:
+            self._init(parent.degree(), parent)
+
+    def __init__(self, parent, x, coerce=True, copy=True):
+        cdef Py_ssize_t i
+        cdef Integer z
+        # we have to do this to avoid a garbage collection error in dealloc
+        for i from 0 <= i < self._degree:
+            mpz_init(self._entries[i])
+        if isinstance(x, (list, tuple)):
+            if len(x) != self._degree:
+                raise TypeError, "x must be a list of the right length"
+            for i from 0 <= i < self._degree:
+                z = Integer(x[i])
+                mpz_set(self._entries[i], z.value)
+            return
+        if x != 0:
+            raise TypeError, "can't initialize vector from nonzero non-list"
+                
+    def __dealloc__(self):
+        cdef Py_ssize_t i
+        if self._entries:
+            for i from 0 <= i < self._degree:
+                mpz_clear(self._entries[i])
+            sage_free(self._entries)
+
+    cdef int _cmp_c_impl(left, Element right) except -2:
+        """
+        EXAMPLES:
+            sage: v = vector(ZZ, [0,0,0,0])
+            sage: v == 0
+            True
+            sage: v == 1
+            False
+            sage: v == v
+            True
+            sage: w = vector(ZZ, [-1,0,0,0])
+            sage: w < v
+            True
+            sage: w > v
+            False
+        """
+        cdef Py_ssize_t i
+        cdef int c
+        for i from 0 <= i < left.degree():
+            c = mpz_cmp(left._entries[i], (<Vector_integer_dense>right)._entries[i])
+            if c < 0:
+                return -1
+            elif c > 0:
+                return 1
+        return 0
+
+    def __len__(self):
+        return self._degree
+
+    def __setitem__(self, Py_ssize_t i, x):
+        cdef Integer z
+        if i < 0 or i >= self._degree:
+            raise IndexError
+        else:
+            z = Integer(x)
+            mpz_set(self._entries[i], z.value)
+            
+    def __getitem__(self, Py_ssize_t i):
+        """
+        Return the ith entry of self.
+        """
+        cdef Integer z
+        z = PY_NEW(Integer)
+        if i < 0 or i >= self._degree:
+            raise IndexError, 'index out of range'
+        else:
+            mpz_set(z.value, self._entries[i])
+            return z
+
+    def __reduce__(self):
+        return (unpickle_v0, (self._parent, self.list(), self._degree))
+
+    cdef ModuleElement _add_c_impl(self, ModuleElement right):
+        cdef Vector_integer_dense z, r
+        r = right
+        z = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init(z._entries[i])
+            mpz_add(z._entries[i], self._entries[i], r._entries[i])
+        return z
+        
+
+    cdef ModuleElement _sub_c_impl(self, ModuleElement right):
+        cdef Vector_integer_dense z, r
+        r = right
+        z = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init(z._entries[i])
+            mpz_sub(z._entries[i], self._entries[i], r._entries[i])
+        return z
+        
+    cdef Vector _vector_times_vector_c_impl(self, Vector right):
+        cdef Vector_integer_dense z, r
+        r = right
+        z = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init(z._entries[i])
+            mpz_mul(z._entries[i], self._entries[i], r._entries[i])
+        return z
+        
+    cdef ModuleElement _rmul_c_impl(self, RingElement left):
+        cdef Vector_integer_dense z
+        cdef Integer a
+        a = left
+        z = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init_set(z._entries[i], self._entries[i])
+            mpz_mul(z._entries[i], z._entries[i], a.value)
+        return z
+
+    cdef ModuleElement _lmul_c_impl(self, RingElement right):
+        cdef Vector_integer_dense z
+        cdef Integer a
+        a = right
+        z = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init_set(z._entries[i], self._entries[i])
+            mpz_mul(z._entries[i], z._entries[i], a.value)
+        return z
+
+    cdef ModuleElement _neg_c_impl(self):
+        cdef Vector_integer_dense z
+        z = self._new_c()
+        cdef Py_ssize_t i
+        for i from 0 <= i < self._degree:
+            mpz_init_set(z._entries[i], self._entries[i])
+            mpz_neg(z._entries[i], z._entries[i])
+        return z
+
+
+
+
+def unpickle_v0(parent, entries, degree):
+    # If you think you want to change this function, don't.
+    # Instead make a new version with a name like
+    #    make_FreeModuleElement_generic_dense_v1
+    # and changed the reduce method below.
+    cdef Vector_integer_dense v
+    v = PY_NEW(Vector_integer_dense)
+    v._init(degree, parent)
+    cdef Integer z
+    for i from 0 <= i < degree:
+        z = Integer(entries[i])
+        mpz_init_set(v._entries[i], z.value)
+    return v
diff -r c62f94993946 -r a7ec047172ff sage/rings/arith.py
--- a/sage/rings/arith.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/rings/arith.py	Fri Feb 23 15:16:47 2007 -0800
@@ -711,6 +711,7 @@ def next_prime(n, proof=True):
         sage: next_prime(2004)
         2011
     """
+    n = integer_ring.ZZ(n)
     if n < 2:   # negatives are not prime. 
         return integer_ring.ZZ(2)
     if n == 2:
diff -r c62f94993946 -r a7ec047172ff sage/rings/finite_field_givaro.pxd
--- a/sage/rings/finite_field_givaro.pxd	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/rings/finite_field_givaro.pxd	Fri Feb 23 15:16:47 2007 -0800
@@ -10,7 +10,7 @@ cdef extern from "Python.h":
     ctypedef struct PyObject
     int PyObject_TypeCheck(object o, PyTypeObject *t)
 
-cdef extern from "givaro-config.h":
+cdef extern from "givaro/givconfig.h":
     pass
 
 cdef extern from "givaro/givrandom.h":
diff -r c62f94993946 -r a7ec047172ff sage/rings/integer.pyx
--- a/sage/rings/integer.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/rings/integer.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -588,7 +588,7 @@ cdef class Integer(sage.structure.elemen
 
     cdef RingElement _div_c_impl(self, RingElement right):
         r"""
-        Computes a \over{b}
+        Computes \frac{a}{b}
         
         EXAMPLES:
             sage: a = Integer(3) ; b = Integer(4)
@@ -615,7 +615,7 @@ cdef class Integer(sage.structure.elemen
 
     def __floordiv__(x, y):
         r"""
-        Computes the whole part of self \over{other}
+        Computes the whole part of \frac{self}{other}
         
         EXAMPLES:
             sage: a = Integer(321) ; b = Integer(10)
diff -r c62f94993946 -r a7ec047172ff sage/rings/integer_ring.pyx
--- a/sage/rings/integer_ring.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/rings/integer_ring.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -73,7 +73,7 @@ cdef extern from "stdlib.h":
 cdef extern from "stdlib.h":
     long random()
     void srandom(unsigned int seed)
-k = randrange(0,2**32)
+k = randrange(0,int(2)**int(32))
 srandom(k)
 
 cdef gmp_randstate_t state
diff -r c62f94993946 -r a7ec047172ff sage/rings/multi_polynomial_element.py
--- a/sage/rings/multi_polynomial_element.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/rings/multi_polynomial_element.py	Fri Feb 23 15:16:47 2007 -0800
@@ -744,7 +744,7 @@ class MPolynomial_polydict(Polynomial_si
         no ring 'ring' is provided.
 
         EXAMPLES:
-            sage: x, y = MPolynomialRing(ZZ,2,'xy').gens()
+            sage: R.<x, y> = MPolynomialRing(ZZ,2,'xy')
             sage: f = 3*x^2 - 2*y + 7*x^2*y^2 + 5
             sage: f.univariate_polynomial()
             Traceback (most recent call last):
@@ -756,9 +756,6 @@ class MPolynomial_polydict(Polynomial_si
             700*x^2 - 2*x + 305
             sage: g.univariate_polynomial(PolynomialRing(QQ,'z'))
             700*z^2 - 2*z + 305
-            sage: R = PolynomialRing(QQ,'w')
-            sage: R(g)
-            700*w^2 - 2*w + 305
         """
         if not self.is_univariate():
             raise TypeError, "polynomial must involve at most one variable"
diff -r c62f94993946 -r a7ec047172ff sage/server/notebook/worksheet.py
--- a/sage/server/notebook/worksheet.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/server/notebook/worksheet.py	Fri Feb 23 15:16:47 2007 -0800
@@ -348,7 +348,7 @@ class Worksheet:
             if S._expect != None:
                 return S
         except AttributeError:
-            S = Sage(maxread = 1)
+            S = Sage(maxread = 1, path = self.__dir)
         S._start(block_during_init=False)
         verbose("Initializing SAGE.")
         os.environ['PAGER'] = 'cat'
diff -r c62f94993946 -r a7ec047172ff sage/structure/element.pyx
--- a/sage/structure/element.pyx	Fri Feb 23 15:16:07 2007 -0800
+++ b/sage/structure/element.pyx	Fri Feb 23 15:16:47 2007 -0800
@@ -1762,6 +1762,19 @@ whereas y has parent '%s'"""%(x,y,parent
     return x, y
 
 def canonical_coercion(x, y):
+    """
+    canonical_coercion(x,y) is what is called before doing an
+    arithmetic operation between x and y.  It returns a pair (z,w)
+    such that z is got from x and w from y via canonical coercion and
+    the parents of z and w are identical.
+
+    EXAMPLES:
+        sage: A = Matrix([[0,1],[1,0]])
+        sage: canonical_coercion(A,1)
+        ([0 1]
+        [1 0], [1 0]
+        [0 1])
+    """
     return canonical_coercion_c(x,y)
 
 cdef canonical_coercion_c(x, y):
diff -r c62f94993946 -r a7ec047172ff setup.py
--- a/setup.py	Fri Feb 23 15:16:07 2007 -0800
+++ b/setup.py	Fri Feb 23 15:16:47 2007 -0800
@@ -262,6 +262,10 @@ complex_double_vector = Extension('sage.
                            libraries = ['gsl', CBLAS, 'pari', 'gmp'],define_macros=[('GSL_DISABLE_DEPRECATED','1')],include_dirs=[SAGE_ROOT+'/local/lib/python2.5/site-packages/numpy/core/include/numpy'])
 
 
+vector_integer_dense = Extension('sage.modules.vector_integer_dense',
+                                 ['sage/modules/vector_integer_dense.pyx'],
+                                 libraries = ['gmp'])
+
 gsl_array = Extension('sage.gsl.gsl_array',['sage/gsl/gsl_array.pyx'],
                 libraries=['gsl',CBLAS],define_macros=[('GSL_DISABLE_DEPRECATED','1')])
 
@@ -285,6 +289,8 @@ ext_modules = [ \
     
     complex_double_vector,
     real_double_vector,
+    vector_integer_dense,
+    
     ec, 
     pari, 
 
